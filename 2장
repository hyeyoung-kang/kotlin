```kotlin
2장에서 다루는 내용
> 함수, 변수, 클래스, enum, 프로퍼티를 선언하는 방법
> 제어구조
> 스마트 캐스트
> 예외 던지기와 예외 잡기
```

# 2.1  기본 요소 : 함수와 변수

## 2.1.1 Hello, World!

```kotlin
fun main(args: Array<String>) {
		println("Hello, world!")
}
```

- 함수 선언할때 fun 키워드 사용,
- 파라미터 이름 뒤에 그 파라미터 타입을 쓴다.
- 함수를 최상위 수준에 정의할수 있다. (자바와 달리)꼭 클래스안에 함수를 넣어야 할 필요가 없다.
- 배영도 일반적인 클래스와 마찬가지, 코틀린에서는 자바와 달리 배열 처리를 위한 문법 존재하지 않음.
- System.out.println → println 사용, 자바 라이브러리 함수를 간결하게 사용할수 있도록 래퍼 제공
- ; 세미콜론 붙이지 않아도 좋다!

## 2.1.2 함수

결과를 반환하는 함수

```kotlin
fun max(a: Int, b: Int): Int {
		return if(a >b) a else b
}
```

더 간결하게 표현, 

```kotlin
fun max(a: Int, b:Int): Int = if(a>b) a else b
```

본문이 중괄호로 둘러싸인 함수를 블록이 본문인 함수

등호와 식으로 이뤄진 함수를 식이 본문 함수라고 한다. 

아래와 같이 반환타입을 생략하면 더 간결하게 사용할수 있다, 여기서 반환타입을 생략할수 있는 이유는

식이 본문인 함수는 사용자가 반환타입을 적지 않아도 컴파일러가 함수 본문식을 분석해 식의 결과 타입을 함수 반환타입으로 정해준다.  이 기능을 “타입추론”이라고 한다. 

단, 식이 본문인 경우에만 반환타입 생략 가능, 블록이 본문인 함수는 반환타입 지정, return을 지정해야 한다. 

```kotlin
fun max(a: Int, b:Int) = if(a>b) a else b
```

## 2.1.3 변수

코틀린에서는 키워드로 변수 선언시작하는 대신, 변수 이름 뒤에 타입을 명시하거나 생략가능하다. 

```kotlin
val question = “삶, 우주, 그리고 모든 것에 대한 궁극적인 질문”
val answer = 42 
val answer: Int = 42
```

타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정한다. 

초기화 식이 없다면, 반드시 타입 지정 필요!!

### 변경가능한 변수, 변경불가능한 변수

- val( value) - 변경 불가능한(immutable) 참조를 저장하는 변수다. 초기화후 재 대입 불가. 자바이 final
- var(variable) - 변경 가능한(mutable) 참조다, 자바의 일반변수

기본적으로 모든 변수를 val 키워드를 사용해 불편변수로 선언하고, 꼭 필요할 경우에만 var로 변경하라.

```kotlin
val message: String
if (canPerformOperation()) {
		message = "Success"
		// ... 연산을 수행한다. 
} else {
		message = "Failed"
}
```

val 참조자체는 불편이라도, 그 참조가 가리키는 객체의 내부값은 변경될 수 있다. 

```kotlin
val languages = arrayListOf("Java") <-- 불변참조를 선언
languages.add("Kotlin") <-- 참조가 가리키는 객체 내부를 변경한다.  
```

var 키워드를 사용하면 변수의 값은 변경가능하지만, 변수의 타입은 고정이다. 

```kotlin
val answer = 42 
answer = "no answer" - 컴파일 오류 발생 "Error:type mismatch"
```

필요시 강제 형 변환(coerce) 해야함. 

## 2.1.4 더 쉽게 문자열 형식 지정 : 문자열 템플릿

문자열 리터럴의 필요하곳에 변수를 넣되, 변수 앞에 $를 추가한다. 

$를 출력하고 싶다면 \를 사용해 이스케이프 시켜야 함. 

```kotlin
fun main(args: Array<String>) {
		val name = if (args.size > 0) args[0] else "Kotlin"
		println("Hello, $name")
}

//  중괄호로 둘러싼 식안에서 큰 따옴표를 사용할 수도 있다!
fun main(args: Array<String>) {
	  println("Hello, ${if(args.size>0) args[0] else "someone"}")
}
```

# 2.2 클래스와 프로퍼티

name property를 가진 Person 클래스 

- 자바

```kotlin
public class Person {
		private final String name;

		public Person(String name) {
				this.name = name;
		}

		public String getName() {
				return name;
		}
}
```

- 코틀린

```kotlin
class Person(val name: String)
```

public 가시성 변경자가 사라짐, 코틀린의 기본 가시성은 public 이므로 변경자를 생략 가능

2.2.1 프로퍼티

자바에서는 필드와 접근자를 묶어 프로퍼티라 부른다, 코틀린은 프로퍼티를 언어 기본기능으로 제공. 

클래스에서 프로퍼티 선언은 val, var 키워드 사용하여 선언

간결한 Person클래스 정의 뒤에는 원래 자바와 동일한 내부 구현이 숨어 있다. 

```kotlin
class Person(
		val name: String, // 읽기 전용 프로퍼티로, 코틀린은 (비공개) 필드와 필드를 읽는 단순한 (공개) 게터를 만들어 낸다. 
		var isMarried: Boolean // 쓸 수 있는 프로퍼티로, 코틀린은 (비공개)필드, (공개) 게터/세터를 만들어 낸다. 
)
```

자바

```kotlin
>> Person person = new Person("Bob", true);
>> System.out.println(person.getName());
Bob

>> System.out.println(person.isMarried());
true
```

코틀린

```kotlin
>> val person = Person("Bob", true) <- new 키워드 사용안함.
>> println(person.name) <- 프로퍼티 이름을 직접 사용해도 코틀린이 자동으로 게터를 호출해준다. 
Bob

>> println(pesion.isMarried)
true
```

게터를 호출하는 대신 프로퍼티를 직접 사용한다. 

2.2.2 커스텀 접근자 

정사각형 여부는 굳이 필드에 저장할 필요없이, 게터로만 존재, 클라이언트가 프로퍼티에 접근할때마다 매번 다시 계산. 

```kotlin
class Rectangle(val height:Int, val width:Int) {
    val isSquare: Boolean
      get(){   <-- 프로퍼티 게터 선언
	      return height == width 
      }
}

>>> val rectangle = Rectangle(41, 43)
>>> println(rectangle.isSquare)
false
```

2.2.3 코틀린 소스코드 구조: 디렉토리와 패키지 

import 키워드사용,  패키지 선언과 임포트문

```kotlin
package geometry.shape <- 패키지 선언
import java.util.Random

class Rectangle(val height:Int, val width:Int) {
    val isSquare: Boolean
      get(){ 
	      return height == width 
      }
}

fun createRandomRectangle(): Rectangle {
		val random = Random()
		return Rectangle(random.nextInt(), random.nextInt())
}
```

다른 패키지에 있는 함수 임포트

```kotlin
package geometry.example

import geometry.shapes.createRandomRectangle <-- 이름으로 함수 임포트 하기 

fun main(args: Array<String>) {
		println(createRandomRectangle().isSquare) <-- true가 아주 드물게 출력
}
```

코틀린은 패키지 구조와 디렉토리 구조가 맞아 떨어질 필요는 없다, 

하지만 대부분 자바와 같이 패키지별로 디렉토리를 구성하는 편이 낫다. 자바와 코틀린을 함께 사용하는 프로젝트에서는 자바의 방식을 따르는게 중요한다. 마이그시에 문제가 생길수 있음. 

여러 클래스를 한 파일에 넣는것을 주저하지말, 특히나 소스코드가 아주 작은 경우엔 더!! 

# 2.3 선택 표현과 처리 : enum과 when

## 2.3.1 enum 클래스 정의

enum 은 자바 선언보다 코틀린 선언에 더 많은 키워드를 써야 하는 흔치 않은 예다. 

```kotlin
enum class Color {
  RED, ORANGE
}
```

enum은 단순히 값만 열거하는 존재가 아님, enum클래스 안에도 프로퍼티나 메소드를 정의할수 있다. 

```kotlin
enum class Color(
   val r: Int, val g: Int, val b: Int <-- 상수의 프로퍼티 정의
) {
    RED(255, 0, 0), ORANGE(255, 165, 0), <-- 각 상수를 생성할때 그에 대한 프로퍼티 값을 지정,
    YELLOW(255, 255, 0), GREEN(0, 255, 0), BLUE(0, 0, 255), 
    INDIGO(75, 0, 130), VIOLET(238, 130, 238); <-- 세미콜론 반드시 사용

    fun rgb() = (r * 256 + g) * 256 + b <-- enum클래스 안에서 메서드 정의
}
```

## 2.3.2 when으로 enum클래스 다루기

자바의 swith에 해당하는 코틀린 구성요소는 when, 

자바 switch와 달리 when절에서는 각 분기 끝에 break를 넣지 않아도 된다. 

```kotlin
fun getMnemonic(color: Color) =
  when (color) {
      Color.RED -> "Richard"
      Color.ORANGE -> "Of"
      Color.YELLOW -> "York"
      Color.GREEN -> "Gave"
      Color.BLUE -> "Battle"
      Color.INDIGO -> "In"
      Color.VIOLET -> "Vain"
}
// 한 분기안에서 여러 값을 매치 패턴으로 사용가능, 콤마로 분리한다. 
fun getMnemonic(color: Color) = when(color) {
		Color.RED, Color.ORANGE -> "warm"
		Color.GREEN -> "neutral"
		Color.BLUE, Color.INDIGO, Color.VIOLET -> "cold"
}
```

```kotlin
import ch02.colors.Color <- Color 클래스 import
import ch02.colors.Color.* <- 짧은 이름으로 사용하기 위해 enum상수를 모두 import

fun getMnemonic(color: Color) = when(color) {
		RED, ORANGE -> "warm"
		GREEN -> "neutral"
		BLUE, INDIGO, VIOLET -> "cold"
}
```

## 2.3.3 when과 임의의 객체를 함께 사용

## 2.3.4 인자 없는 when사용

## 2.3.5 스마트 캐스트 : 타입 검사와 타입 캐스트를 조합.

2.3.6 리팩토링 : if를 when으로 변경

2.3.7 if와 when의 분기에서 블록 사용

2.4 대상을 이터레이션 while과 for 루프 

2.4.1 while 루프 

2.4.2 수에 대한 이터레이션 : 범위와 수열 

2.4.3 맵에 대한 이터레이션

2.4.4. in으로 컬렉션이나 범위의 원소 검사 

2.5. 코틀린 예외처리

2.5.1 try, catch, finally

2.5.2 try를 식으로 사용.

2.6 요약
